// Copyright (C) 2016-2019 Semtech (International) AG. All rights reserved.
// Copyright (C) 2014-2016 IBM Corporation. All rights reserved.
//
// This file is subject to the terms and conditions defined in file 'LICENSE',
// which is part of this source code package.

//#define DEBUG_TX
//#define DEBUG_RX

#include "lmic.h"

// ----------------------------------------
// RADIO STATE
static struct {
    ostime_t irqtime;
    osjob_t irqjob;
    u1_t diomask;
    u1_t txmode;
} state;

// stop radio, disarm interrupts, cancel jobs
static void radio_stop (void) {
    hal_disableIRQs();
    // put radio to sleep
    radio_sleep();
    // disable antenna switch
    hal_pin_rxtx(0);
    // power-down TCXO
    hal_pin_tcxo(0);
    // disable antenna switch
    // disable IRQs in HAL
    hal_irqmask_set(0);
    // cancel radio job
    os_clearCallback(&state.irqjob);
    // clear state
    state.diomask = 0;
    hal_enableIRQs();
}

// guard timeout in case no completion interrupt is generated by radio
// protected job.
static void radio_irq_timeout (osjob_t* j) {
    (void)j; // unused
    hal_disableIRQs();

    // stop everything (antenna switch, hal irqs, sleep, irq job)
    radio_stop();

    // re-initialize radio if tx operation timed out
    if (state.txmode) {
        radio_init(true);
    }

    // enable IRQs!
    hal_enableIRQs();

    LMIC_DEBUG_PRINTF("WARNING: radio irq timeout!\r\n");

    // indicate timeout
    LMIC.dataLen = 0;

    // run os job (use preset func ptr)
    os_setCallback(&LMIC.osjob, LMIC.osjob.func);
}

void radio_set_irq_timeout (ostime_t timeout) {
    // schedule irq-protected timeout function
    os_setTimedCallback(&state.irqjob, timeout, radio_irq_timeout);
}

// (run by irqjob)
static void radio_irq_func (osjob_t* j) {
    (void)j; // unused
    // call radio-specific processing function
    if( radio_irq_process(state.irqtime, state.diomask) ) {
        // current radio operation has completed
        radio_stop(); // (disable antenna switch and HAL irqs, make radio sleep)

        // run LMIC job (use preset func ptr)
        os_setCallback(&LMIC.osjob, LMIC.osjob.func);
    }

    // clear irq state (job has been run)
    state.diomask = 0;
}

// called by hal exti IRQ handler
// (all radio operations are performed on radio job!)
void radio_irq_handler (u1_t diomask) {
    radio_irq_handler_v2(diomask, os_getTime());
}

void radio_irq_handler_v2 (u1_t diomask, ostime_t ticks) {
    // make sure previous job has been run
    ASSERT( state.diomask == 0 );

    // save interrupt source and time
    state.irqtime = ticks;
    state.diomask = diomask;

    // schedule irq job
    // (timeout job will be replaced, intermediate interrupts must rewind timeout!)
    os_setCallback(&state.irqjob, radio_irq_func);
}

static const oslmic_radio_interface_t *s_radio = NULL;


int radio_init (bool calibrate){
    switch(hal_radio_type()){
#if defined(CFG_sx126x_radio)
        case LMIC_RADIO_SX1261:
        case LMIC_RADIO_SX1262:
            s_radio = sx126x_interface();
            break;
#endif

#if defined(CFG_sx127x_radio)
        case LMIC_RADIO_SX1276:
            s_radio = sx127x_interface();
            break;
#endif
        default:
            ASSERT(0); // Invalid radio type.
    }
    return s_radio->init(calibrate);
}

bool radio_irq_process (ostime_t irqtime, u1_t diomask){
    return s_radio->irq_process(irqtime, diomask);
}

void radio_starttx (bool txcontinuous){
    s_radio->starttx(txcontinuous);
}

void radio_startrx (bool rxcontinuous){
    s_radio->startrx(rxcontinuous);
}

void radio_sleep (void){
    s_radio->sleep();
}

void radio_cca (void){
    s_radio->cca();
}

void radio_cad (void){
    s_radio->cad();
}

void radio_cw (void){
    s_radio->cw();
}

void radio_generate_random (u1_t *buffer, u1_t len){
    s_radio->generate_random(buffer, len);
}

void os_radio (u1_t mode) {
    switch (mode) {
        case RADIO_RST:
            radio_stop();
            break;

        case RADIO_TX:
            radio_stop();
#ifdef DEBUG_TX
            if( isFsk(LMIC.rps) ) {
                LMIC_DEBUG_PRINTF("TX[mod=FSK,nocrc=%d\n", getNocrc(LMIC.rps));
            } else {
                ASSERT(isLora(LMIC.rps));
                LMIC_DEBUG_PRINTF("TX[mod=LoRa,sf=%d,bw=%d,cr=4/%d,nocrc=%d,ih=%d\n",
                             getSf(LMIC.rps) - SF7 + 7, 125 << (getBw(LMIC.rps) - BW125),
                             getCr(LMIC.rps) - CR_4_5 + 5, getNocrc(LMIC.rps), getIh(LMIC.rps));
            }
            LMIC_DEBUG_PRINTF(",fcnt=%lu,freq=%.1F,pow=%d,len=%d%s]: %.80h\r\n",
                         (LMIC.seqnoUp ? LMIC.seqnoUp - 1 : 0),
                         LMIC.freq, 6,
                         LMIC.txpow, LMIC.dataLen,
                         (LMIC.pendTxPort != 0 && (LMIC.frame[OFF_DAT_FCT] & FCT_ADRARQ)) ? ",ADRARQ" : "",
                         LMIC.frame, LMIC.dataLen);
#endif
            // transmit frame now (wait for completion interrupt)
            radio_starttx(false);
            // set timeout for tx operation (should not happen)
            state.txmode = 1;
            radio_set_irq_timeout(os_getTime() + ms2osticks(20) + calcAirTime(LMIC.rps, LMIC.dataLen) * 110 / 100);
            break;

        case RADIO_RX:
            radio_stop();
#ifdef DEBUG_RX
            if( isFsk(LMIC.rps) ) {
                LMIC_DEBUG_PRINTF("RX_MODE[mod=FSK,nocrc=%d", getNocrc(LMIC.rps));
            } else {
                ASSERT(isLora(LMIC.rps));
                LMIC_DEBUG_PRINTF("RX_MODE[mod=LoRa,sf=%d,bw=%d,cr=4/%d,nocrc=%d,ih=%d",
                             getSf(LMIC.rps) - SF7 + 7, 125 << (getBw(LMIC.rps) - BW125),
                             getCr(LMIC.rps) - CR_4_5 + 5, getNocrc(LMIC.rps), getIh(LMIC.rps));
            }
            debug_printf_continue(",freq=%.1F,rxtime=%.0F]\r\n",
                         LMIC.freq, 6,
                         LMIC.rxtime, 0);
#endif
            // receive frame at rxtime/now (wait for completion interrupt)
            radio_startrx(false);
            // set timeout for rx operation (should not happen, might be updated by radio driver)
            state.txmode = 0;
            radio_set_irq_timeout(LMIC.rxtime + ms2osticks(5) + calcAirTime(LMIC.rps, 255) * 110 / 100);
            break;

        case RADIO_RXON:
            radio_stop();
#ifdef DEBUG_RX
            if( isFsk(LMIC.rps) ) {
                LMIC_DEBUG_PRINTF("RXON_MODE[mod=FSK,nocrc=%d", getNocrc(LMIC.rps));
            } else {
                ASSERT(isLora(LMIC.rps));
                LMIC_DEBUG_PRINTF("RXON_MODE[mod=LoRa,sf=%d,bw=%d,cr=4/%d,nocrc=%d,ih=%d",
                             getSf(LMIC.rps) - SF7 + 7, 125 << (getBw(LMIC.rps) - BW125),
                             getCr(LMIC.rps) - CR_4_5 + 5, getNocrc(LMIC.rps), getIh(LMIC.rps));
            }
            debug_printf_continue(",freq=%.1F]\r\n", LMIC.freq, 6);
#endif
            // start scanning for frame now (wait for completion interrupt)
            state.txmode = 0;
            radio_startrx(true);
            break;

        case RADIO_TXCW:
            radio_stop();
            // transmit continuous wave (until abort)
            radio_cw();
            break;

        case RADIO_CCA:
            radio_stop();
            // clear channel assessment
            radio_cca();
            break;

        case RADIO_INIT:
            // reset and calibrate radio (uses LMIC.freq)
            radio_init(true);
            break;

        case RADIO_TXCONT:
            radio_stop();
            radio_starttx(true);
            break;

        case RADIO_CAD:
            radio_stop();
            // set timeout for cad/rx operation (should not happen, might be updated by radio driver)
            state.txmode = 0;
            radio_set_irq_timeout(os_getTime() + ms2osticks(10) + calcAirTime(LMIC.rps, 255) * 110 / 100);
            // channel activity detection and rx if preamble symbol found
            radio_cad();
            break;
    }
}

static u1_t randbuf[16];
void radio_rand_init(){
    radio_generate_random(randbuf, sizeof(randbuf));
    randbuf[0] = 16;
}

u1_t radio_rand1 () {
    u1_t i = randbuf[0];
    ASSERT( i != 0 );
    if( i==16 ) {
        os_aes(AES_ENC, randbuf, 16); // encrypt seed with any key
        i = 0;
    }
    u1_t v = randbuf[i++];
    randbuf[0] = i;
    return v;
}

// TODO(nwiles): Rename this to os_getMaxJitter()?
ostime_t os_getRadioRxRampup (void) {
    return RX_RAMPUP_DEFAULT;
}
